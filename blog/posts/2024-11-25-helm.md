---
title_pl: "Kubernetes od zera #2 â€“ Helm i pierwszy chart"
title_en: "Kubernetes from scratch #2 â€“ Helm and first chart"
date: 2025-11-25
description_pl: Drugi wpis z serii o Kubernetesie â€“ dodanie Helm charts do prostego klastra z poprzedniego artykuÅ‚u.
description_en: Second post in the Kubernetes series â€“ adding Helm charts to the simple cluster from the previous article.
---

## PL

## 1. WstÄ™p

W tym wpisie rozszerzamy poprzedni przykÅ‚ad prostego klastra Kubernetes, dodajÄ…c do niego Helm charts. Najpierw wprowadzam kilka zmian w Å›rodowisku, astÄ™pnie przechodzÄ™ do minimalnego  przykÅ‚adu pracy z Helmem, pokazujÄ…c podstawowÄ… strukturÄ™ chartu i sposÃ³b wykonania pierwszego wdroÅ¼enia. Celem jest pokazanie, Å¼e Helm moÅ¼na wykorzystywaÄ‡ w bardzo prosty sposÃ³b, jednoczeÅ›nie stanowi on solidny fundament pod bardziej zÅ‚oÅ¼one scenariusze.

## 2. Czym jest Helm

Helm to menedÅ¼er pakietÃ³w dla Kubernetes, ktÃ³rego zadaniem jest uproszczenie procesu wdraÅ¼ania i zarzÄ…dzania aplikacjami. Kubernetes czÄ™sto wymaga wielu manifestÃ³w YAML opisujÄ…cych rÃ³Å¼ne zasoby: Deployment, Service, ConfigMapy, ingressy i inne. Helm pozwala zebraÄ‡ je w jednÄ…, spÃ³jnÄ… strukturÄ™, ktÃ³rÄ… moÅ¼na Å‚atwo instalowaÄ‡, aktualizowaÄ‡ i usuwaÄ‡. Helm dziaÅ‚a jako warstwa nad Kubernetesem â€” generuje manifesty, a nastÄ™pnie stosuje je w klastrze. NajwiÄ™kszÄ… korzyÅ›ciÄ… jest moÅ¼liwoÅ›Ä‡ parametryzacji i ponownego wykorzystania tych samych definicji w rÃ³Å¼nych Å›rodowiskach.

### 2.1 Czym sÄ… Helm Charts
Helm charts to paczki opisujÄ…ce aplikacjÄ™ lub jej fragment w Kubernetesie.
MoÅ¼na o nich myÅ›leÄ‡ jak o projekcie, ktÃ³ry zawiera wszystkie pliki
potrzebne do wdroÅ¼enia konkretnego komponentu.
Typowy chart skÅ‚ada siÄ™ z czterech gÅ‚Ã³wnych elementÃ³w:

* **Chart** â€“ metadane chartu: nazwa, wersja, opis, wersja API.
* **Values** â€“ plik z parametrami konfiguracyjnymi.
* katalog **templates/** â€“ szablony manifestÃ³w Kubernetes
  (Deployment, Service, ConfigMap itd.).
* katalog **charts/** â€“ zaleÅ¼noÅ›ci (w prostych projektach zwykle pusty).

Chart jest uporzÄ…dkowanym zbiorem plikÃ³w, dziÄ™ki czemu umoÅ¼liwia wdraÅ¼anie aplikacji w sposÃ³b przewidywalny i powtarzalny. Sprawdza siÄ™ zarÃ³wno w maÅ‚ych eksperymentach, jak i w duÅ¼ych Å›rodowiskach produkcyjnych.

## 3. Implementacja

> Kod ÅºrÃ³dÅ‚owy do serii wpisÃ³w znajduje siÄ™ w repozytorium GitHub:
> [https://github.com/mpiotro4/k8s_demo/tree/blog/2024-11-25-helm](https://github.com/mpiotro4/k8s_demo/tree/blog/2024-11-25-helm)

### 3.1 Kilka zmian na poczÄ…tku

Na wstÄ™pie parÄ™ zmian w porÃ³wnaniu do ostatniego wpisu. Po pierwsze nasze proste API staÅ‚o siÄ™ mniej proste, wyÅ›wietla parÄ™ dodatkowych informacji:

```
mpio@Marcins-MacBook-Air ~ % curl localhost:8080 | jq
{
"hostname": "Marcins-MacBook-Air.local",
"message": "default message",
"namespace": null,
"node_name": null,
"pod_ip": null,
"status": "ok"
}
```

OprÃ³cz tego przerzuciÅ‚em siÄ™ z klastra Ranchera na Kind.

```
mpio@Marcins-MacBook-Air ~ % kind create cluster
Creating cluster "kind" ...
âœ“ Ensuring node image (kindest/node:v1.34.0) ğŸ–¼
âœ“ Preparing nodes ğŸ“¦
âœ“ Writing configuration ğŸ“œ
âœ“ Starting control-plane ğŸ•¹ï¸
âœ“ Installing CNI ğŸ”Œ
âœ“ Installing StorageClass ğŸ’¾
Set kubectl context to "kind-kind"
```

PoniewaÅ¼ Kind nie posiada wbudowanego load balancera, typ `LoadBalancer` nie dziaÅ‚a â€” Service pozostaje w stanie â€pendingâ€. Najprostsze obejÅ›cie to `kubectl port-forward`:

```
kubectl port-forward service/demo-api 8080:8080
```

Po przekierowaniu portÃ³w aplikacja dziaÅ‚a wewnÄ…trz klastra:

```
{
"hostname": "demo-api-7df9444d9c-f2w47",
"namespace": "default",
"node_name": "kind-control-plane",
"pod_ip": "10.244.0.5",
"status": "ok"
}
```

### 3.2 Minimalny przykÅ‚ad

Aby rozpoczÄ…Ä‡ pracÄ™ z Helmem, generujemy przykÅ‚adowy chart:

```
helm create simple-chart
```

Powstaje peÅ‚ny â€starter chartâ€ z wieloma plikami. Aby uproÅ›ciÄ‡ projekt, usuwamy zbÄ™dne elementy i zostawiamy jedynie:

```
simple-chart/
â”œâ”€â”€ Chart.yaml
â”œâ”€â”€ values.yaml
â””â”€â”€ templates/
    â”œâ”€â”€ deployment.yaml
    â””â”€â”€ service.yaml
```

Plik `Chart.yaml` zawiera metadane, `values.yaml` moÅ¼e przechowywaÄ‡ parametry konfiguracyjne, a katalog `templates/` zawiera szablony manifestÃ³w.
Teraz moÅ¼na zainstalowaÄ‡ chart:
```
helm install my-release-name ./demo-chart
```
W efekcie aplikacja zostaje wdroÅ¼ona do klastra,
podobnie jak w poprzednim wpisie.

### 3.3 TrochÄ™ mniej minimalny przykÅ‚ad

Warto uporzÄ…dkowaÄ‡ nazwy i parametry, zamiast powtarzaÄ‡ identyczne wartoÅ›ci w wielu miejscach. PrzykÅ‚ad z `deployment.yaml` pokazuje powtarzajÄ…cÄ… siÄ™ nazwÄ™ `demo-api`. Lepszym rozwiÄ…zaniem jest przeniesienie tych wartoÅ›ci do `values.yaml`.

```
appName: demo-api
config:
  APP_PORT: "8080"
  APP_MESSAGE: "Hello from Helm Values"
```

W szablonie Deploymentu moÅ¼na teraz odwoÅ‚ywaÄ‡ siÄ™ do nich przez `.Values`:

```yaml
metadata:
  name: { { .Values.appName } }
  labels:
    app: { { .Values.appName } }
```

AnalogicznÄ… zmianÄ™ wykonujemy w `configmap.yaml`.
Po zaktualizowaniu chartu wykonujemy:

```
helm upgrade my-release-name ./demo-chart
```

Aby Pody otrzymaÅ‚y nowe wartoÅ›ci,
naleÅ¼y wymusiÄ‡ rollout Deploymentu:

```
kubectl rollout restart deployment demo-api
```

Po restarcie:

```
{
    "hostname": "demo-api-865cc7f5d4-8bhkl",
    "message": "Hello from Helm Values",
    "namespace": "default",
    "node_name": "kind-control-plane",
    "pod_ip": "10.244.0.20",
    "status": "ok"
}
```

### 4. PodziaÅ‚ na Å›rodowiska

Gdy mamy juÅ¼ za sobÄ… pierwsze wykorzystanie Helm values, moÅ¼emy przejÅ›Ä‡ do czegoÅ› bardziej praktycznego, czyli wdraÅ¼ania tej samej aplikacji w kilku Å›rodowiskach. Jest to bardzo powszechna praktyka w organizacjach pracujÄ…cych zespoÅ‚owo, poniewaÅ¼ pozwala rozwijaÄ‡, testowaÄ‡ i weryfikowaÄ‡ zmiany bez wpÅ‚ywu na uÅ¼ytkownikÃ³w koÅ„cowych.
Typowy podziaÅ‚ Å›rodowisk wyglÄ…da nastÄ™pujÄ…co:

* **PROD** â€“ Å›rodowisko produkcyjne, z ktÃ³rego korzystajÄ… uÅ¼ytkownicy koÅ„cowi,
* **DEV** â€“ Å›rodowisko developerskie, wykorzystywane do bieÅ¼Ä…cej pracy i testowania zmian,
* **QA** â€“ Å›rodowisko przeznaczone dla zespoÅ‚Ã³w QA, gdzie aplikacja podlega testom przed wdroÅ¼eniem na produkcjÄ™.

DziÄ™ki Helm values moÅ¼emy dla kaÅ¼dego Å›rodowiska definiowaÄ‡ inne parametry takie jak:

* wersja obrazu Dockera,
* konfiguracja aplikacji (np. zmienne Å›rodowiskowe),
* integracje z zewnÄ™trznymi systemami (np. mocki zamiast prawdziwych usÅ‚ug).

> Uwaga praktyczna:
> W tym przykÅ‚adzie Å›rodowiska (DEV/QA/PROD) sÄ… rozdzielone przy pomocy namespaceâ€™Ã³w w jednym klastrze Kubernetes. Jest to podejÅ›cie czÄ™sto stosowane lokalnie, w maÅ‚ych zespoÅ‚ach oraz w celach edukacyjnych, poniewaÅ¼ jest tanie i proste w utrzymaniu.
>W Å›rodowiskach produkcyjnych najczÄ™Å›ciej spotyka siÄ™ jednak inny model, w ktÃ³rym kaÅ¼de Å›rodowisko dziaÅ‚a w osobnym klastrze Kubernetes (np. osobny cluster dla DEV, STAGE i PROD), a namespaceâ€™y sÅ‚uÅ¼Ä… gÅ‚Ã³wnie do separacji aplikacji, zespoÅ‚Ã³w lub tenantÃ³w w obrÄ™bie jednego Å›rodowiska.
> Na potrzeby tego wpisu namespaceâ€™y peÅ‚niÄ… rolÄ™ Å›rodowisk, co pozwala skupiÄ‡ siÄ™ na mechanice Helm values bez wprowadzania dodatkowej zÅ‚oÅ¼onoÅ›ci infrastrukturalnej.

#### 4.1 Implementacja

Na poczÄ…tek rozszerzyÅ‚em plik `values.yaml` z poprzedniej czÄ™Å›ci o nowy parametr `namespace`. To on bÄ™dzie odpowiadaÅ‚ za logiczne odseparowanie poszczegÃ³lnych Å›rodowisk w klastrze Kubernetes.

```yaml
appName: demo-api
config:
  name: demo-api-config
  APP_PORT: 8081
  APP_MESSAGE: "Hello from Helm Values"
namespace: "default"
image:
  name: kddny/demo_api
  tag: latest
```

W bazowym pliku `values.yaml` parametr `namespace` ustawiony jest na `default` jednak w praktyce rzadko korzysta siÄ™ z  tego namespaceâ€™u dla aplikacji Zamiast tego tworzymy osobne pliki z nadpisaniami wartoÅ›ci dla konkretnych Å›rodowisk.
PrzykÅ‚adowy plik `values-dev.yaml` dla Å›rodowiska DEV moÅ¼e wyglÄ…daÄ‡ nastÄ™pujÄ…co:

```yaml
config:
  APP_MESSAGE: "Hello from DEV"
namespace: dev
```

ZdefiniowaÅ‚em tutaj wyÅ‚Ä…cznie te wartoÅ›ci, ktÃ³re rÃ³Å¼niÄ… siÄ™ od domyÅ›lnych PozostaÅ‚e pola zostanÄ… automatycznie odziedziczone z gÅ‚Ã³wnego `values.yaml`. W analogiczny sposÃ³b moÅ¼na przygotowaÄ‡ pliki `values-qa.yaml` oraz `values-prod.yaml`.
Aby wdroÅ¼yÄ‡ aplikacjÄ™ w Å›rodowisku DEV, uÅ¼ywam komendy `helm install` z dodatkowymi parametrami:

```
helm install my-release-name-dev ./demo-chart \
  --values ./demo-chart/values.yaml \
  -f ./demo-chart/values-dev.yaml \
  -n dev
```

Znaczenie poszczegÃ³lnych elementÃ³w:
* `my-release-name-dev` â€“ nazwa releasu, unikalna w obrÄ™bie klastra,
* `./demo-chart` â€“ Å›cieÅ¼ka do charta Helm,
* `--values` / `-f` â€“ pliki z wartoÅ›ciami, ktÃ³re Helm Å‚Ä…czy w jednÄ… konfiguracjÄ™ (kolejne nadpisujÄ… poprzednie),
* `-n dev` â€“ namespace, w ktÃ³rym zostanÄ… utworzone zasoby.

W analogiczny sposÃ³b wdroÅ¼yÅ‚em aplikacjÄ™ rÃ³wnieÅ¼ w Å›rodowisku PROD, uÅ¼ywajÄ…c osobnego pliku z wartoÅ›ciami i innej nazwy releasu.
Na koniec wystarczy wystawiÄ‡ odpowiednie porty lokalnie. Dla Å›rodowiska DEV przekierowujÄ™ port 8081:

```
kubectl port-forward -n dev service/demo-api 8081:8081
```

Ta komenda oznacza:

* `-n dev` â€“ namespace, w ktÃ³rym znajduje siÄ™ Service,
* `service/demo-api` â€“ nazwa zasobu Service,
* `8081:8081` â€“ mapowanie portu lokalnego na port serwisu w klastrze.

Po uruchomieniu port-forward moÅ¼emy sprawdziÄ‡ dziaÅ‚anie aplikacji:

```
curl localhost:8081 | jq
{
  "hostname": "demo-api-5cd7597b5c-mdfmt",
  "message": "Hello from DEV",
  "namespace": "dev",
  "node_name": "kind-control-plane",
  "pod_ip": "10.244.0.22",
  "status": "ok"
}
```

Analogicznie dziaÅ‚a Å›rodowisko produkcyjne, uruchomione w innym namespaceâ€™ie i z innÄ… konfiguracjÄ…:

```
curl localhost:8082 | jq
{
  "hostname": "demo-api-5cd7597b5c-22l9m",
  "message": "Hello from PROD",
  "namespace": "prod",
  "node_name": "kind-control-plane",
  "pod_ip": "10.244.0.23",
  "status": "ok"
}
```

DziÄ™ki takiemu podejÅ›ciu jedna definicja Helm chartu moÅ¼e obsÅ‚ugiwaÄ‡ wiele Å›rodowisk, rÃ³Å¼niÄ…cych siÄ™ wyÅ‚Ä…cznie konfiguracjÄ…, a nie kodem czy manifestami Kubernetes.

#### 5. Podsumowanie

W tym wpisie pokazano podstawy pracy z Helmem: od stworzenia minimalnego chartu, przez parametryzacjÄ™ manifestÃ³w za pomocÄ… values.yaml, aÅ¼ po wdraÅ¼anie aplikacji w wielu Å›rodowiskach.
Helm nie zastÄ™puje Kubernetes, ale upraszcza zarzÄ…dzanie manifestami, pozwala uniknÄ…Ä‡ duplikacji i uÅ‚atwia aktualizacje aplikacji. DziÄ™ki temu ta sama definicja chartu moÅ¼e byÄ‡ uÅ¼ywana wielokrotnie, zmieniajÄ…c jedynie konfiguracjÄ™.

## EN