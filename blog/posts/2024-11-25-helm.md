---
title_pl: "Kubernetes od zera #2 â€“ Helm i pierwszy chart"
title_en: "Kubernetes from scratch #2 â€“ Helm and first chart"
date: 2025-11-25
description_pl: Drugi wpis z serii o Kubernetesie â€“ dodanie Helm charts do prostego klastra z poprzedniego artykuÅ‚u.
description_en: Second post in the Kubernetes series â€“ adding Helm charts to the simple cluster from the previous article.
---

## PL

## 1. WstÄ™p

W tym wpisie rozszerzamy poprzedni przykÅ‚ad prostego klastra Kubernetes,
dodajÄ…c do niego Helm charts. Najpierw wprowadzam kilka zmian w Å›rodowisku,
astÄ™pnie przechodzÄ™ do minimalnego przykÅ‚adu pracy z Helmem,
pokazujÄ…c podstawowÄ… strukturÄ™ chartu i sposÃ³b wykonania pierwszego wdroÅ¼enia.
Celem jest pokazanie, Å¼e Helm moÅ¼na wykorzystywaÄ‡ w bardzo prosty sposÃ³b,
a jednoczeÅ›nie stanowi on solidny fundament pod bardziej zÅ‚oÅ¼one scenariusze.

## 2. Czym jest Helm

Helm to menedÅ¼er pakietÃ³w dla Kubernetes, ktÃ³rego zadaniem jest
uproszczenie procesu wdraÅ¼ania i zarzÄ…dzania aplikacjami.
Kubernetes czÄ™sto wymaga wielu manifestÃ³w YAML opisujÄ…cych rÃ³Å¼ne zasoby:
Deployment, Service, ConfigMapy, ingressy i inne.
Helm pozwala zebraÄ‡ je w jednÄ…, spÃ³jnÄ… strukturÄ™,
ktÃ³rÄ… moÅ¼na Å‚atwo instalowaÄ‡, aktualizowaÄ‡ i usuwaÄ‡.
Helm dziaÅ‚a jako warstwa nad Kubernetesem â€” generuje manifesty,
a nastÄ™pnie stosuje je w klastrze.
NajwiÄ™kszÄ… korzyÅ›ciÄ… jest moÅ¼liwoÅ›Ä‡ parametryzacji i ponownego
wykorzystania tych samych definicji w rÃ³Å¼nych Å›rodowiskach.

### 2.1 Czym sÄ… Helm Charts

Helm charts to paczki opisujÄ…ce aplikacjÄ™ lub jej fragment w Kubernetesie.
MoÅ¼na o nich myÅ›leÄ‡ jak o projekcie, ktÃ³ry zawiera wszystkie pliki
potrzebne do wdroÅ¼enia konkretnego komponentu.

Typowy chart skÅ‚ada siÄ™ z czterech gÅ‚Ã³wnych elementÃ³w:

* **Chart** â€“ metadane chartu: nazwa, wersja, opis, wersja API.
* **Values** â€“ plik z parametrami konfiguracyjnymi.
* katalog **templates/** â€“ szablony manifestÃ³w Kubernetes
  (Deployment, Service, ConfigMap itd.).
* katalog **charts/** â€“ zaleÅ¼noÅ›ci (w prostych projektach zwykle pusty).

Chart jest uporzÄ…dkowanym zbiorem plikÃ³w,
dziÄ™ki czemu umoÅ¼liwia wdraÅ¼anie aplikacji w sposÃ³b przewidywalny i powtarzalny.
Sprawdza siÄ™ zarÃ³wno w maÅ‚ych eksperymentach, jak i w duÅ¼ych Å›rodowiskach produkcyjnych.

## 3. Implementacja

> Kod ÅºrÃ³dÅ‚owy do serii wpisÃ³w znajduje siÄ™ w repozytorium GitHub:
> [https://github.com/mpiotro4/k8s_demo/tree/blog/2024-11-25-helm](https://github.com/mpiotro4/k8s_demo/tree/blog/2024-11-25-helm)

### 3.1 Kilka zmian na poczÄ…tku

Na wstÄ™pie parÄ™ zmian w porÃ³wnaniu do ostatniego wpisu.
Po pierwsze nasze proste API staÅ‚o siÄ™ mniej proste,
wyÅ›wietla parÄ™ dodatkowych informacji:

```
mpio@Marcins-MacBook-Air ~ % curl localhost:8080 | jq
{
"hostname": "Marcins-MacBook-Air.local",
"message": "default message",
"namespace": null,
"node_name": null,
"pod_ip": null,
"status": "ok"
}
```

OprÃ³cz tego przerzuciÅ‚em siÄ™ z klastra Ranchera na Kind.

```
mpio@Marcins-MacBook-Air ~ % kind create cluster
Creating cluster "kind" ...
âœ“ Ensuring node image (kindest/node:v1.34.0) ğŸ–¼
âœ“ Preparing nodes ğŸ“¦
âœ“ Writing configuration ğŸ“œ
âœ“ Starting control-plane ğŸ•¹ï¸
âœ“ Installing CNI ğŸ”Œ
âœ“ Installing StorageClass ğŸ’¾
Set kubectl context to "kind-kind"
```

PoniewaÅ¼ Kind nie posiada wbudowanego load balancera,
typ `LoadBalancer` nie dziaÅ‚a â€” Service pozostaje w stanie â€pendingâ€.
Najprostsze obejÅ›cie to `kubectl port-forward`:

```
kubectl port-forward service/demo-api 8080:8080
```

Po przekierowaniu portÃ³w aplikacja dziaÅ‚a wewnÄ…trz klastra:

```
{
"hostname": "demo-api-7df9444d9c-f2w47",
"namespace": "default",
"node_name": "kind-control-plane",
"pod_ip": "10.244.0.5",
"status": "ok"
}
```

### 3.2 Minimalny przykÅ‚ad

Aby rozpoczÄ…Ä‡ pracÄ™ z Helmem, generujemy przykÅ‚adowy chart:

```
helm create simple-chart
```

Powstaje peÅ‚ny â€starter chartâ€ z wieloma plikami.
Aby uproÅ›ciÄ‡ projekt, usuwamy zbÄ™dne elementy i zostawiamy jedynie:

```
simple-chart/
â”œâ”€â”€ Chart.yaml
â”œâ”€â”€ values.yaml
â””â”€â”€ templates/
    â”œâ”€â”€ deployment.yaml
    â””â”€â”€ service.yaml
```

Plik `Chart.yaml` zawiera metadane,
`values.yaml` moÅ¼e przechowywaÄ‡ parametry konfiguracyjne,
a katalog `templates/` zawiera szablony manifestÃ³w.

Teraz moÅ¼na zainstalowaÄ‡ chart:

```
helm install my-release-name ./demo-chart
```

W efekcie aplikacja zostaje wdroÅ¼ona do klastra,
podobnie jak w poprzednim wpisie.

### 3.3 TrochÄ™ mniej minimalny przykÅ‚ad

Warto uporzÄ…dkowaÄ‡ nazwy i parametry,
zamiast powtarzaÄ‡ identyczne wartoÅ›ci w wielu miejscach.
PrzykÅ‚ad z `deployment.yaml` pokazuje powtarzajÄ…cÄ… siÄ™ nazwÄ™ `demo-api`.
Lepszym rozwiÄ…zaniem jest przeniesienie tych wartoÅ›ci do `values.yaml`.

```
appName: demo-api
config:
  APP_PORT: "8080"
  APP_MESSAGE: "Hello from Helm Values"
```

W szablonie Deploymentu moÅ¼na teraz odwoÅ‚ywaÄ‡ siÄ™ do nich przez `.Values`:

```yaml
metadata:
  name: {{ .Values.appName }}
  labels:
    app: {{ .Values.appName }}
```

AnalogicznÄ… zmianÄ™ wykonujemy w `configmap.yaml`.

Po zaktualizowaniu chartu wykonujemy:

```
helm upgrade my-release-name ./demo-chart
```

Aby Pody otrzymaÅ‚y nowe wartoÅ›ci,
naleÅ¼y wymusiÄ‡ rollout Deploymentu:

```
kubectl rollout restart deployment demo-api
```

Po restarcie:

```
{
    "hostname": "demo-api-865cc7f5d4-8bhkl",
    "message": "Hello from Helm Values",
    "namespace": "default",
    "node_name": "kind-control-plane",
    "pod_ip": "10.244.0.20",
    "status": "ok"
}
```

### 4. PodziaÅ‚ na Å›rodowiska

Gdy juÅ¼ mamy za sobÄ… pierwsze wykorzystanie Helm values, moÅ¼emy zrobiÄ‡ coÅ› bardziej praktycznego, czyli wdroÅ¼yÄ‡ aplikacje w kilku wersjach. Jest to praktyka stosowana w wielu organizacjach aby umoÅ¼liwiÄ‡ duÅ¼ym zespoÅ‚om prace nad systemem. PrzykÅ‚adowym podziaÅ‚em na Å›rodowiska moÅ¼e byÄ‡:

* PROD - produkcja, to czego uÅ¼ywa klient
* DEV - developerskie, devloperzy testujÄ… tam swoje zmiany
* QA - quality assurance, Å›rodwisko przeznaczone dla teamÃ³w QA

DziÄ™ki takiemu podziaÅ‚owi moÅ¼emy z poziomy helm values ustawiÄ‡ wersje dockerowego obrazu z ktÃ³rego ma korzystaÄ‡, poÅ‚Ä…czenie z bazÄ… danych czy zdecydowaÄ‡ czy integracje majÄ… byÄ‡ zamockowane.

#### 4.1 Implementacja

Najpierw do `values.yaml` z poprzedniej czÄ™Å›ci dodaÅ‚em nowy parametr `namespace`. To on bÄ™dzie odrÃ³Å¼niaÅ‚ poszczegolne workloady w klustrze od siebie.

```yaml
appName: demo-api
config:
  name: demo-api-config
  APP_PORT: 8081
  APP_MESSAGE: "Hello from Helm Values"
namespace: "default"
image:
  name: kddny/demo_api
  tag: latest
```

W tym konkretnym pliku jest on ustawiony na `default` aczkolwiek moÅ¼na go Å‚atwo nadpisaÄ‡ tworzÄ…c kolejny, podrzÄ™dny plik z wartoÅ›ciami. Wystarczy stworzyÄ‡ plik o dowolnej nazwie np. `vales-dev.yaml` ktÃ³ry bÄ™dzie przechowywaÅ‚ wartoÅ›ci dla Å›rodowiska DEV. 

```yaml
config:
  APP_MESSAGE: "Hello from DEV"
namespace: dev
```

W tym pliku ustawiÅ‚em wartoÅ›ci tylko tych pÃ³l ktÃ³re chce zmieniÄ‡, reszta zostanie odziedziczona. W ten sam sposÃ³b tworze Helm values dla Å›rodowisk QA oraz PROD.


Teraz wystarczy wdroÅ¼yÄ‡ aplikacje z wykorzystaniem Helm values w wersji DEV. Aby to zrobiÄ‡ uÅ¼ywam komendy helm install, tylko tym razem 
TODO: wytÅ‚umacz tutaj te parametry

```
mpio@Marcins-MacBook-Air helm install my-release-name-dev ./demo-chart --values ./demo-chart/values.yaml -f ./demo-chart/values-dev.yaml -n dev
NAME: my-release-name-dev
LAST DEPLOYED: Mon Dec  8 19:19:09 2025
NAMESPACE: dev
STATUS: deployed
REVISION: 1
DESCRIPTION: Install complete
TEST SUITE: None
```

W analogiczny sposÃ³b wdroÅ¼yÅ‚em rÃ³wnieÅ¼ aplikacje w wersji PROD.

Teraz wystarczy jedynie przekierowaÄ‡ odpowiedni port. Service DEV przekieruje na port 8081 z kolei serwis PROD na port 8082.
```
kubectl port-forward -n dev service/demo-api 8081:8081
```
todo: wytÅ‚umacz elementy tej komendy

I to wszystko, moÅ¼emy teraz sprawdziÄ‡ jak dziaÅ‚ajÄ… nasze Å›rodowiska:

```
mpio@Marcins-MacBook-Air ~ % curl localhost:8081 | jq
{
{"hostname":"demo-api-5cd7597b5c-mdfmt","message":"Hello from DEV","namespace":"dev","node_name":"kind-control-plane","pod_ip":"10.244.0.22","status":"ok"}
}
```

```
mpio@Marcins-MacBook-Air ~ % curl localhost:8082 | jq
{"hostname":"demo-api-5cd7597b5c-22l9m","message":"Hello from PROD","namespace":"prod","node_name":"kind-control-plane","pod_ip":"10.244.0.23","status":"ok"}
```

#### 5. Podsumowanie

Helm pozwala uporzÄ…dkowaÄ‡ wdroÅ¼enia Kubernetes,
w szczegÃ³lnoÅ›ci przez templating, parametryzacjÄ™ i wersjonowanie releasÃ³w.
Mechanizm jest prosty, ale bardzo elastyczny.
W kolejnym wpisie wykorzystamy go w bardziej rozbudowanym przykÅ‚adzie.

## EN