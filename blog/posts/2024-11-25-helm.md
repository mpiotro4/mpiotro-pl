---
title_pl: "Kubernetes od zera #2 â€“ Helm i pierwszy chart"
title_en: "Kubernetes from scratch #2 â€“ Helm and first chart"
date: 2025-11-25
description_pl: Drugi wpis z serii o Kubernetesie â€“ dodanie Helm charts do prostego klastra z poprzedniego artykuÅ‚u.
description_en: Second post in the Kubernetes series â€“ adding Helm charts to the simple cluster from the previous article.
---

## PL

## 1. WstÄ™p

W tym wpisie rozszerzamy poprzedni przykÅ‚ad prostego klastra Kubernetes,
dodajÄ…c do niego Helm charts. Najpierw wprowadzam kilka zmian w Å›rodowisku,
astÄ™pnie przechodzÄ™ do minimalnego przykÅ‚adu pracy z Helmem,
pokazujÄ…c podstawowÄ… strukturÄ™ chartu i sposÃ³b wykonania pierwszego wdroÅ¼enia.
Celem jest pokazanie, Å¼e Helm moÅ¼na wykorzystywaÄ‡ w bardzo prosty sposÃ³b,
a jednoczeÅ›nie stanowi on solidny fundament pod bardziej zÅ‚oÅ¼one scenariusze.

## 2. Czym jest Helm

Helm to menedÅ¼er pakietÃ³w dla Kubernetes, ktÃ³rego zadaniem jest
uproszczenie procesu wdraÅ¼ania i zarzÄ…dzania aplikacjami.
Kubernetes czÄ™sto wymaga wielu manifestÃ³w YAML opisujÄ…cych rÃ³Å¼ne zasoby:
Deployment, Service, ConfigMapy, ingressy i inne.
Helm pozwala zebraÄ‡ je w jednÄ…, spÃ³jnÄ… strukturÄ™,
ktÃ³rÄ… moÅ¼na Å‚atwo instalowaÄ‡, aktualizowaÄ‡ i usuwaÄ‡.
Helm dziaÅ‚a jako warstwa nad Kubernetesem â€” generuje manifesty,
a nastÄ™pnie stosuje je w klastrze.
NajwiÄ™kszÄ… korzyÅ›ciÄ… jest moÅ¼liwoÅ›Ä‡ parametryzacji i ponownego
wykorzystania tych samych definicji w rÃ³Å¼nych Å›rodowiskach.

### 2.1 Czym sÄ… Helm Charts

Helm charts to paczki opisujÄ…ce aplikacjÄ™ lub jej fragment w Kubernetesie.
MoÅ¼na o nich myÅ›leÄ‡ jak o projekcie, ktÃ³ry zawiera wszystkie pliki
potrzebne do wdroÅ¼enia konkretnego komponentu.

Typowy chart skÅ‚ada siÄ™ z czterech gÅ‚Ã³wnych elementÃ³w:

* **Chart** â€“ metadane chartu: nazwa, wersja, opis, wersja API.
* **Values** â€“ plik z parametrami konfiguracyjnymi.
* katalog **templates/** â€“ szablony manifestÃ³w Kubernetes
  (Deployment, Service, ConfigMap itd.).
* katalog **charts/** â€“ zaleÅ¼noÅ›ci (w prostych projektach zwykle pusty).

Chart jest uporzÄ…dkowanym zbiorem plikÃ³w,
dziÄ™ki czemu umoÅ¼liwia wdraÅ¼anie aplikacji w sposÃ³b przewidywalny i powtarzalny.
Sprawdza siÄ™ zarÃ³wno w maÅ‚ych eksperymentach, jak i w duÅ¼ych Å›rodowiskach produkcyjnych.

## 3. Implementacja

> Kod ÅºrÃ³dÅ‚owy do serii wpisÃ³w znajduje siÄ™ w repozytorium GitHub:
> [https://github.com/mpiotro4/k8s_demo/tree/blog/2024-11-25-helm](https://github.com/mpiotro4/k8s_demo/tree/blog/2024-11-25-helm)

### 3.1 Kilka zmian na poczÄ…tku

Na wstÄ™pie parÄ™ zmian w porÃ³wnaniu do ostatniego wpisu.
Po pierwsze nasze proste API staÅ‚o siÄ™ mniej proste,
wyÅ›wietla parÄ™ dodatkowych informacji:

```
mpio@Marcins-MacBook-Air ~ % curl localhost:8080 | jq
{
"hostname": "Marcins-MacBook-Air.local",
"message": "default message",
"namespace": null,
"node_name": null,
"pod_ip": null,
"status": "ok"
}
```

OprÃ³cz tego przerzuciÅ‚em siÄ™ z klastra Ranchera na Kind.

```
mpio@Marcins-MacBook-Air ~ % kind create cluster
Creating cluster "kind" ...
âœ“ Ensuring node image (kindest/node:v1.34.0) ğŸ–¼
âœ“ Preparing nodes ğŸ“¦
âœ“ Writing configuration ğŸ“œ
âœ“ Starting control-plane ğŸ•¹ï¸
âœ“ Installing CNI ğŸ”Œ
âœ“ Installing StorageClass ğŸ’¾
Set kubectl context to "kind-kind"
```

PoniewaÅ¼ Kind nie posiada wbudowanego load balancera,
typ `LoadBalancer` nie dziaÅ‚a â€” Service pozostaje w stanie â€pendingâ€.
Najprostsze obejÅ›cie to `kubectl port-forward`:

```
kubectl port-forward service/demo-api 8080:8080
```

Po przekierowaniu portÃ³w aplikacja dziaÅ‚a wewnÄ…trz klastra:

```
{
"hostname": "demo-api-7df9444d9c-f2w47",
"namespace": "default",
"node_name": "kind-control-plane",
"pod_ip": "10.244.0.5",
"status": "ok"
}
```

### 3.2 Minimalny przykÅ‚ad

Aby rozpoczÄ…Ä‡ pracÄ™ z Helmem, generujemy przykÅ‚adowy chart:

```
helm create simple-chart
```

Powstaje peÅ‚ny â€starter chartâ€ z wieloma plikami.
Aby uproÅ›ciÄ‡ projekt, usuwamy zbÄ™dne elementy i zostawiamy jedynie:

```
simple-chart/
â”œâ”€â”€ Chart.yaml
â”œâ”€â”€ values.yaml
â””â”€â”€ templates/
    â”œâ”€â”€ deployment.yaml
    â””â”€â”€ service.yaml
```

Plik `Chart.yaml` zawiera metadane,
`values.yaml` moÅ¼e przechowywaÄ‡ parametry konfiguracyjne,
a katalog `templates/` zawiera szablony manifestÃ³w.

Teraz moÅ¼na zainstalowaÄ‡ chart:

```
helm install my-release-name ./demo-chart
```

W efekcie aplikacja zostaje wdroÅ¼ona do klastra,
podobnie jak w poprzednim wpisie.

### 3.3 TrochÄ™ mniej minimalny przykÅ‚ad

Warto uporzÄ…dkowaÄ‡ nazwy i parametry,
zamiast powtarzaÄ‡ identyczne wartoÅ›ci w wielu miejscach.
PrzykÅ‚ad z `deployment.yaml` pokazuje powtarzajÄ…cÄ… siÄ™ nazwÄ™ `demo-api`.
Lepszym rozwiÄ…zaniem jest przeniesienie tych wartoÅ›ci do `values.yaml`.

```
appName: demo-api
config:
  APP_PORT: "8080"
  APP_MESSAGE: "Hello from Helm Values"
```

W szablonie Deploymentu moÅ¼na teraz odwoÅ‚ywaÄ‡ siÄ™ do nich przez `.Values`:

```yaml
metadata:
  name: {{ .Values.appName }}
  labels:
    app: {{ .Values.appName }}
```

AnalogicznÄ… zmianÄ™ wykonujemy w `configmap.yaml`.

Po zaktualizowaniu chartu wykonujemy:

```
helm upgrade my-release-name ./demo-chart
```

Aby Pody otrzymaÅ‚y nowe wartoÅ›ci,
naleÅ¼y wymusiÄ‡ rollout Deploymentu:

```
kubectl rollout restart deployment demo-api
```

Po restarcie:

```
{
    "hostname": "demo-api-865cc7f5d4-8bhkl",
    "message": "Hello from Helm Values",
    "namespace": "default",
    "node_name": "kind-control-plane",
    "pod_ip": "10.244.0.20",
    "status": "ok"
}
```

### 4. Podsumowanie

Helm pozwala uporzÄ…dkowaÄ‡ wdroÅ¼enia Kubernetes,
w szczegÃ³lnoÅ›ci przez templating, parametryzacjÄ™ i wersjonowanie releasÃ³w.
Mechanizm jest prosty, ale bardzo elastyczny.
W kolejnym wpisie wykorzystamy go w bardziej rozbudowanym przykÅ‚adzie.

## EN