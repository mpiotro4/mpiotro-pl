---
title_pl: "Kubernetes od zera #2 â€“ Helm i pierwszy chart"
title_en: "Kubernetes from scratch #2 â€“ Helm and first chart"
date: 2025-11-25
description_pl: Drugi wpis z serii o Kubernetesie â€“ dodanie Helm charts do prostego klastra z poprzedniego artykuÅ‚u.
description_en: Second post in the Kubernetes series â€“ adding Helm charts to the simple cluster from the previous article.
---

## PL

## 1. WstÄ™p

W tym wpisie rozbudowujemy poprzedni przykÅ‚ad prostego klastra Kubernetes, 
dodajÄ…c do niego Helm charts. Najpierw wprowadzam kilka zmian w Å›rodowisku, 
potem przechodzÄ™ do minimalnego przykÅ‚adu pracy z Helmem, pokazujÄ…c, 
jak wyglÄ…da podstawowa struktura chartu i jak wykonaÄ‡ pierwsze wdroÅ¼enie.
CaÅ‚oÅ›Ä‡ ma na celu zademonstrowanie, Å¼e Helm moÅ¼e byÄ‡ uÅ¼ywany w sposÃ³b 
bardzo prosty, a jednoczeÅ›nie zapewnia solidne fundamenty pod bardziej 
zÅ‚oÅ¼one scenariusze.

## 2. Czym jest Helm

Helm to menedÅ¼er pakietÃ³w dla Kubernetes, ktÃ³rego zadaniem jest
uproszczenie procesu wdraÅ¼ania i zarzÄ…dzania aplikacjami.
Kubernetes wymaga czÄ™sto wielu manifestÃ³w YAML opisujÄ…cych
Deployment, Service, ConfigMapy, role, ingressy i inne zasoby.
Helm pozwala zebraÄ‡ je w jednÄ…, spÃ³jnÄ… strukturÄ™, ktÃ³rÄ… moÅ¼na 
Å‚atwo zainstalowaÄ‡, zaktualizowaÄ‡ lub usunÄ…Ä‡ za pomocÄ… pojedynczych komend.
Helm dziaÅ‚a jak warstwa nad Kubernetesem â€” generuje manifesty,
a nastÄ™pnie stosuje je do klastra.
NajwiÄ™kszÄ… korzyÅ›ciÄ… jest moÅ¼liwoÅ›Ä‡ parametryzacji i ponownego 
wykorzystania tych samych definicji w rÃ³Å¼nych Å›rodowiskach.

### 2.1 Czym sÄ… Helm Charts

Helm charts to paczki opisujÄ…ce aplikacjÄ™ lub jej fragment w Kubernetesie. MoÅ¼na myÅ›leÄ‡ o nich jak o â€projekcieâ€, w ktÃ³rym zorganizowane sÄ… wszystkie pliki potrzebne do zainstalowania danego komponentu.

Typowy chart skÅ‚ada siÄ™ z czterech gÅ‚Ã³wnych elementÃ³w:

- **Chart** - Zawiera podstawowe metadane chartu: nazwÄ™, 
wersjÄ™, opis, wersjÄ™ API Helma.
- **Values** - Plik z wartoÅ›ciami konfiguracyjnymi. 
Chart moÅ¼e ich uÅ¼ywaÄ‡ w szablonach, 
a uÅ¼ytkownik moÅ¼e je nadpisywaÄ‡ podczas instalacji.
- katalog **templates/** - NajwaÅ¼niejszy katalog chartu. 
Zawiera szablony manifestÃ³w Kubernetes, 
ktÃ³re Helm przetwarza do finalnego YAML-a.
MogÄ… to byÄ‡ Deployment, Service, ConfigMap, Ingress itd.
- katalog **charts/** - Katalog na zaleÅ¼noÅ›ci, czyli inne charty
wykorzystywane przez ten chart. W prostych projektach pozostaje pusty.

Chart jest wiÄ™c uporzÄ…dkowanym zbiorem plikÃ³w, 
ktÃ³ry pozwala wdraÅ¼aÄ‡ aplikacjÄ™ w powtarzalny i przewidywalny sposÃ³b. 
DziÄ™ki temu Helm uÅ‚atwia pracÄ™ zarÃ³wno w maÅ‚ych eksperymentach,
jak i w duÅ¼ych Å›rodowiskach produkcyjnych.

## 3. Implementacja

> CaÅ‚y kod ÅºrÃ³dÅ‚owy z serii wpisÃ³w o Kubernetesie znajduje siÄ™ w repozytorium na GitHubie pod linkiem poniÅ¼ej.
> KaÅ¼dy wpis ma swÃ³j osobny branch.
> https://github.com/mpiotro4/k8s_demo/tree/blog/2024-11-25-helm


### 3.1 Pare zmian zanim zaczniemy

Na wstÄ™pie parÄ™ zmian w porÃ³wnaniu do ostatniego wpisu.
Po pierwsze nasze proste API staÅ‚o siÄ™ mniej proste, 
wyÅ›wietla parÄ™ dodatkowych informacji:

```

mpio@Marcins-MacBook-Air ~ % curl localhost:8080 | jq
{
"hostname": "Marcins-MacBook-Air.local",
"namespace": null,
"node_name": null,
"pod_ip": null,
"status": "ok"
}

```

Ponadto przerzuciÅ‚em siÄ™ z klastra zapewnianego przez Rancher na Kind.
DziaÅ‚a to nastÄ™pujÄ…co:

```

mpio@Marcins-MacBook-Air ~ % kind create cluster
Creating cluster "kind" ...
âœ“ Ensuring node image (kindest/node:v1.34.0) ğŸ–¼
âœ“ Preparing nodes ğŸ“¦
âœ“ Writing configuration ğŸ“œ
âœ“ Starting control-plane ğŸ•¹ï¸
âœ“ Installing CNI ğŸ”Œ
âœ“ Installing StorageClass ğŸ’¾
Set kubectl context to "kind-kind"
You can now use your cluster with:
kubectl cluster-info --context kind-kind
To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.
mpio@Marcins-MacBook-Air ~ % kubectl config get-contexts
CURRENT   NAME        CLUSTER     AUTHINFO    NAMESPACE

* ```
      kind-kind   kind-kind   kind-kind   
  ```

```

Z racji Å¼e uÅ¼ywamy Kind, konieczna byÅ‚a rÃ³wnieÅ¼ zmiana typu service z 
LoadBalancer na NodePort. W Rancher Desktop typ LoadBalancer dziaÅ‚a, 
poniewaÅ¼ Rancher dostarcza lokalnÄ… implementacjÄ™ load balancera i 
potrafi przydzieliÄ‡ zewnÄ™trzny adres IP. Kind takiego mechanizmu 
nie posiada â€“ to czysty klaster uruchamiany w kontenerach Dockera,
bez komponentu odpowiadajÄ…cego za realizacjÄ™ usÅ‚ug LoadBalancer. 
Dlatego service tego typu nigdy nie dostanie adresu IP i 
pozostaje w stanie â€pendingâ€.

Najprostsze rozwiÄ…zanie to uÅ¼ycie `kubectl port-forward`, 
ktÃ³re tworzy tunel z lokalnego portu do portu service 
w klastrze. kubectl zestawia poÅ‚Ä…czenie z API serverem i 
przekazuje caÅ‚y ruch z twojej maszyny do wskazanego service:

```

mpio@Marcins-MacBook-Air ~ % kubectl port-forward service/demo-api 8080:8080
Forwarding from 127.0.0.1:8080 -> 8080
Forwarding from [::1]:8080 -> 8080

```
```

mpio@Marcins-MacBook-Air ~ % curl localhost:8080 | jq
{
"hostname": "demo-api-7df9444d9c-f2w47",
"namespace": "default",
"node_name": "kind-control-plane",
"pod_ip": "10.244.0.5",
"status": "ok"
}

```

Tym razem widaÄ‡ jak na dÅ‚oni, Å¼e nasza aplikacja dziaÅ‚a wewnÄ…trz klastra.

### 3.2 Minimalny przykÅ‚ad

Jedziemy z Helmem. Najpierw trzeba go oczywiÅ›cie zainstalowaÄ‡, ale to juÅ¼ pominÄ™.
Aby zaczÄ…Ä‡, moÅ¼na wykorzystaÄ‡ nastÄ™pujÄ…cÄ… komendÄ™:

```

mpio@Marcins-MacBook-Air ~ % helm create simple-chart
Creating simple-chart

```

Helm wygenerowaÅ‚ peÅ‚ny â€starter chartâ€ â€“ kompletny zestaw plikÃ³w i katalogÃ³w,
ktÃ³ry ma pokazaÄ‡, jak zbudowany jest typowy chart.
Wygenerowana zostaÅ‚a caÅ‚a struktura: 
`Chart.yaml`, `values.yaml` z duÅ¼Ä… liczbÄ… przykÅ‚adowych parametrÃ³w,
a w katalogu `templates/` wiele zasobÃ³w takich jak Deployment, Service, 
Ingress, HPA, ServiceAccount.

To wszystko jest przydatne przy bardziej rozbudowanych projektach, 
ale w naszym przypadku stanowi wyÅ‚Ä…cznie szum. 
Chcemy mieÄ‡ moÅ¼liwie prosty chart pokazujÄ…cy wyÅ‚Ä…cznie Deployment i Service.
Dlatego caÅ‚oÅ›Ä‡ porzÄ…dkujemy i zostawiamy tylko minimalny zestaw plikÃ³w:

```

simple-chart/
â”œâ”€â”€ Chart.yaml
â”œâ”€â”€ values.yaml
â””â”€â”€ templates/
â”œâ”€â”€ deployment.yaml
â””â”€â”€ service.yaml

```

Plik `Chart.yaml` zawiera podstawowe informacje takie jak nazwa czy wersja.
Plik `values.yaml` z kolei moÅ¼e zawieraÄ‡ wartoÅ›ci konfiguracyjne naszego klastra, lecz na ten moment pozostanie pusty.  
Sam Helm zawsze udostÄ™pnia obiekt `.Values`, natomiast plik `values.yaml` staje siÄ™ istotny dopiero w momencie, 
gdy w szablonach zaczynamy siÄ™ do tych wartoÅ›ci odwoÅ‚ywaÄ‡.  
Pliki `deployment.yaml` oraz `service.yaml` pozostajÄ… bez zmian.

Mamy wszystko, co potrzebne, aby zrobiÄ‡ pierwsze wdroÅ¼enie k8s z Helm charts.
W tym celu wykorzystamy komendÄ™ `helm install`:

```

mpio@Marcins-MacBook-Air DemoApi % helm install my-release-name ./demo-chart
NAME: my-release-name
LAST DEPLOYED: Tue Nov 25 21:01:00 2025
NAMESPACE: default
STATUS: deployed
REVISION: 1
DESCRIPTION: Install complete
TEST SUITE: None

````

Nie bÄ™dÄ™ juÅ¼ tego pokazywaÅ‚, ale efekt koÅ„cowy jest dokÅ‚adnie taki sam,
jak wczeÅ›niej â€“ czyli nasze proste API zostaÅ‚o zdeployowane wewnÄ…trz klastra
k8s. MajÄ…c za sobÄ… ten minimalny przykÅ‚ad, moÅ¼emy przejÅ›Ä‡ do kolejnego
kroku, czyli dodaÄ‡ pierwsze wartoÅ›ci konfiguracyjne do naszego charta.

### 3.3 TrochÄ™ mniej minimalny przykÅ‚ad

Na wstÄ™pie warto zauwaÅ¼yÄ‡, z czego wynika potrzeba posiadania wartoÅ›ci konfiguracyjnych.
Wystarczy spojrzeÄ‡ m.in. na plik `deployment.yaml`:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: demo-api
  labels:
    app: demo-api
spec:
  replicas: 3
  selector:
    matchLabels:
      app: demo-api
  template:
    metadata:
      labels:
        app: demo-api
    spec:
      containers:
      - name: demo-api
        image: kddny/demo_api:latest
        imagePullPolicy: Always
        ports:
        - containerPort: 8080
````

Nazwa `demo-api` pojawia siÄ™ w wielu miejscach manifestÃ³w,
co zwiÄ™ksza ryzyko pomyÅ‚ki. JeÅ›li w przyszÅ‚oÅ›ci chciaÅ‚bym
zmieniÄ‡ nazwÄ™ aplikacji, musiaÅ‚bym zaktualizowaÄ‡ jÄ… rÄ™cznie w
kilku plikach, Å‚atwo przy tym coÅ› przeoczyÄ‡.

Lepszym podejÅ›ciem jest przechowywanie takiej wartoÅ›ci w
jednym miejscu i odwoÅ‚ywanie siÄ™ do niej w szablonach â€” dokÅ‚adnie tak,
jak do parametrÃ³w w pliku konfiguracyjnym.

Aby dodaÄ‡ wartoÅ›ci konfiguracyjne do charta, wystarczy umieÅ›ciÄ‡ wpis w pliku `values.yaml`:

```yaml
appName: demo-api
```

I nastÄ™pnie odwoÅ‚aÄ‡ siÄ™ do konkretnej wartoÅ›ci w pliku `deployment.yaml`:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ .Values.appName }}
  labels:
    app: {{ .Values.appName }}
spec:
  replicas: 3
  selector:
    matchLabels:
      app: {{ .Values.appName }}
  template:
    metadata:
      labels:
        app: {{ .Values.appName }}
    spec:
      containers:
      - name: {{ .Values.appName }}
        image: kddny/demo_api:latest
        imagePullPolicy: Always
        ports:
        - containerPort: 8080
```

Obiekt `.Values` to mechanizm Helma, ktÃ³ry udostÄ™pnia zawartoÅ›Ä‡ pliku `values.yaml`
w szablonach i pozwala parametryzowaÄ‡ manifesty Kubernetes.

Teraz, gdybyÅ›my chcieli np. zmieniÄ‡ nazwÄ™ aplikacji, wystarczy zrobiÄ‡ to
w jednym miejscu.

Nowa wersja Helm chart jest gotowa do wdroÅ¼enia â€” tym razem uÅ¼ywam komendy
`helm upgrade`:

```
mpio@Marcins-MacBook-Air DemoApi % helm upgrade my-release-name ./demo-chart 
Release "my-release-name" has been upgraded. Happy Helming!
NAME: my-release-name
LAST DEPLOYED: Sun Nov 30 20:25:27 2025
NAMESPACE: default
STATUS: deployed
REVISION: 2
DESCRIPTION: Upgrade complete
TEST SUITE: None
```

### 4. Podsumowanie

To tyle w tym minimalnym przykÅ‚adzie. Pokazuje on sedno dziaÅ‚ania Helma:
jest to jedynie warstwa nad Kubernetesem, ktÃ³ra generuje i zarzÄ…dza
manifestami w bardziej uporzÄ…dkowany sposÃ³b. Sam mechanizm jest prosty,
ale daje ogromne moÅ¼liwoÅ›ci â€“ od templatingu, przez wersjonowanie releasÃ³w,
po Å‚atwÄ… aktualizacjÄ™ i rollback.
W kolejnym wpisie przygotujemy coÅ› bardziej rozbudowanego, aby
lepiej wykorzystaÄ‡ potencjaÅ‚ Helm charts.

---

## EN